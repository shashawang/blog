# 浏览器的工作原理与实践

这篇是极客时间专栏的阅读笔记，对这个专栏的**有兴趣是因为**觉得自己dom api和浏览器原理方面比较薄弱，想了解一下浏览器原理到底涉及哪些部分。专栏作者每讲一个小主题都会先强调这个主题的价值，然后要么是循着这个主题一步步推出更关键的信息，要不就是向前追溯到这个问题的来源或旁开关联到相关技术改进，文章结构都很清晰，也能吸引人一步步读下去。本篇说是**笔记**，大部分都是摘抄，每篇读完整理一下重点，避免看的时候感觉很厉害，看完还是零散的信息，整理完可以用作自己浏览器部分的知识体系雏形，以后学习以此为扩展。之前看winter的《重学前端》就想这么干了，但当时很多时候用手机看，不方便整理出文档，这次都用电脑网页打开，画完线就复制出来，不咋多费精力，复制的同时也是放缓阅读速度，给自己认真读重点的机会。这篇笔记基本只是我自己的备忘，抽掉了一些描述看上去干瘪生硬，甚至可能有理解偏差或者少量表述不当，可以用作了解梗概，想学还是推荐直接去看专栏。目前整个专栏的阅读进度大概是百分之七十几，**读完大半的感受**是技术知识的理解是渐进的，以前看《你不知道的javascript》中册没看完就停了，冴羽的深入js系列也是一篇要看好几个小时才能勉强理解，很多东西看完只是摸到了大象的局部，有一些锚点以后继续了解和实践才能慢慢理解更全面，起步晚目前经验少是既成事实，保持热情持续学习长期看这些不是事儿

## 01 | Chrome架构：仅仅打开了1个页面，为什么有4个进程？

浏览器单进程架构时代，不稳定、不流畅、不安全，多进程时代优化了这些问题，但资源占用更高、架构体系更复杂，16年谷歌提出架构要面向服务SOA，且使用弹性架构根据设备性能选择单进程或多进程。

主要进程包括浏览器主进程、渲染进程、GPU进程、网络进程、插件进程。

## 02：TCP协议

FP--网络加载速度--http/ws--TCP/IP：web性能优化、了解 TCP 协议，方便了解 HTTP的实际功能和局限性，之后才会更加深刻地理解为什么要推出 HTTP/2，以及为什么要推出 QUIC 协议，也就是未来的 HTTP/3

IP：把数据包送达目的主机。计算机的地址就称为 IP 地址

UDP：把数据包送达应用程序。UDP 中一个最重要的信息是端口号

TCP：把数据完整地送达应用程序。TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，连接分为三个阶段：建立连接、传输数据和断开连接。TCP 头除了包含了目标端口和本机端口号外，还提供了用于排序的序列号，丢包可以重传，且能排序

## 04：导航流程

构建请求、查找缓存/缓存查找失败、进入网络请求：DNS域名解析/查找DNS 数据缓存获取ip（有明确端口或默认端口）、请求数小于6?等待:和服务器建立 TCP 连接（最上层的应用层协议不一定是最先发起的）、发送http请求、获取响应/重定向、Connection:Keep-Alive?保持连接:断开连接

缓存：强缓存、协商缓存

![img](https://static001.geekbang.org/resource/image/1b/6c/1b49976aca2c700883d48d927f48986c.png)



## 05 、06| 渲染流程：HTML、CSS和JavaScript，是如何变成页面的？

1. 构建 DOM 树

2. 样式计算（Recalculate Style）

   1. 把三种来源的 CSS 转换为浏览器能够理解的结构document.styleSheets
   2. 属性值标准化：转换样式表中的属性值，使其标准化
   3. 计算出 DOM 树中每个节点的具体样式：CSS 的继承（父节点)规则和层叠规则(层叠是 CSS 的一个基本特征，定义了如何合并来自多个源的属性值，在 CSS 处于核心地位，CSS 的全称“层叠样式表”正是强调了这一点)

3. 布局：计算每个元素的几何坐标位置，构建一棵只包含可见元素布局树，dispaly:none的元素没有被包进布局树

4. 分层：为了更加方便地实现一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）

   > 元素**有层叠上下文的属性**或者**需要被剪裁**，满足其中任意一点，就会被提升成为单独一层，明确定位属性的元素position、定义透明属性的元素opacity、使用 CSS 滤镜filter的元素，或文字内容超出div

5. 图层绘制：输出待**绘制指令列表**

6. 栅格化（raster）：绘制列表准备好之后，主线程会把该绘制列表提交（commit）给合成线程；合成线程会将图层**划分为图块**（tile）；栅格化在线程池内（渲染进程维护的）优先根据视口附近的图块生成来位图

   > 光栅化就是按照绘制列表中的指令生成图片。每一个图层都对应一张图片，合成线程有了这些图片之后，会将这些图片合成为“一张”图片，并最终将生成的图片发送到后缓冲区。这就是一个大致的分层、合成流程

7. 快速栅格化（GPU 栅格化）：栅格化过程都会使用 GPU 来加速生成，渲染进程把生成图块的指令发送给 GPU，生成的位图被保存在 GPU 内存中

8. 合成和显示：所有图块都被光栅化，合成线程就会生成绘制图块的命令DrawQuad，然后将该命令提交给浏览器进程。浏览器进程的 viz 组件，根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上

    

根据布局树进行分层，生成分层树，为每个图层生成绘制列表，合成线程合成、切分图块、光栅化（栅格化--图块生成位图，加速需要渲染进程外的GPU进程）图块，完了浏览器进程的viz 组件接收合成线程发过来的 DrawQuad 命令，将页面内容绘制到内存中、显示在屏幕上

减少重排重绘, 方法很多：
\1. 使用 class 操作样式，而不是频繁操作 style：触发repaint reflow的操作尽量放在一起，比如改变dom高度和设置margin分开写，可能会出发两次重排
\2. 避免使用 table 布局
\3. 批量dom 操作，例如 createDocumentFragment，或者使用框架，例如 React
\4. Debounce window resize 事件
\5. 对 dom 属性的读写要分离
\6. will-change: transform 做优化

## 07：变量提升

JavaScript 的执行机制：先编译，再执行。在执行一段 JavaScript 代码之前，会编译代码，并将代码中的函数和变量**声明**（通过 var 声明才会在编译期间提升）保存到执行上下文的变量环境VariableEnvironment中，函数定义存储到堆 (HEAP）中，将该属性值指向堆中函数的位置

关于同名变量和函数的两点处理原则：

1:如果是同名的函数，JavaScript编译阶段会选择最后声明的那个。

2:如果变量和函数同名，那么在编译阶段，变量的声明会被忽略

（函数提升要比变量提升的优先级要高一些，且不会被变量声明覆盖，但是会被变量赋值之后覆盖）

block内部的var变量能够穿透block提升到global scope。JavaScript的Dynamic Scope发生在执行阶段，会产生this binding, prototype chaining search的过程；
变量提升只提升声明(left hand）不提升赋值(right hand)

## 08：调用栈

js执行全局代码时，编译并创建全局执行上下文（除了变量环境还有词法环境）将其压入栈内，生成可执行代码（字节码）并执行，执行过程中遇到函数，创建函数执行上下文压入栈内并执行，执行完改变上下文内容出栈。执行过程中的多个执行上下文通过栈的数据结构来管理，特点是后进先出，跟饭碗一样。

console.trace()可以打印当前函数的调用栈信息，浏览器里的工具用法还要学。调用栈有两个指标，最大栈容量和最大调用深度，满足其中任意一个就会栈溢出

## 09：块级作用域

块级作用域：函数、循环语句、{}代码块、try...catch

ES6 是如何做到既要支持变量提升的特性，又要支持块级作用域的呢：函数内部通过 var 声明的变量，在编译阶段全都被存放到变量环境里面了；通过 let 声明的变量，在编译阶段会被存放到词法环境（Lexical Environment）中。函数内部的块级作用域内，var声明的变量不受块作用域限制，会被提升到函数作用域内部；进入块级作用域不会有编译过程，只不过通过let或者const声明的变量会在进入块级作用域的时被创建，块信息被压入函数上下文的词法环境，执行完改变上下文内容并出栈。（函数只会在第一次执行的时候被编译，所以编译时变量环境和词法环境最顶层数据已经确定了。当执行到块级作用域的时候，块级作用域中通过let和const申明的变量会被追加到词法环境中，当这个块执行结束之后，追加到词法作用域的内容又会销毁掉）

（在词法环境内部，维护了一个小型栈结构，栈底是函数最外层的块级变量，进入一个作用域块后，就会把该作用域块内部的块级变量压到栈顶；当作用域执行完成之后，该作用域的信息就会从栈顶弹出，这就是词法环境的结构。）

1. var myname = "极客时间"
   function showName(){
     console.log(myname);
     if(0){
      var myname = "极客邦"
     }
     console.log(myname);
   }
   showName()
2. function foo(){
        var a = 1
        let b = 2
        {
          let b = 3
          var c = 4
          let d = 5
          console.log(a)
          console.log(b)
        }
        console.log(b) 
        console.log(c)
        console.log(d)
    }   
    foo()
3. let myname= '极客时间'
   {
     console.log(myname) 
     let myname= '极客邦'
   }
   【最终打印结果】：VM6277:3 Uncaught ReferenceError: Cannot access 'myname' before initialization
   【分析原因】：在块作用域内，let声明的变量被提升，但变量只是创建被提升，初始化并没有被提升，在初始化之前使用变量，就会形成一个暂时性死区。
   【拓展】
   var的创建和初始化被提升，赋值不会被提升。
   let的创建被提升，初始化和赋值不会被提升(但只有在变量的词法绑定(LexicalBinding)已经被求值运算后，才能够被访问。)。
   function的创建、初始化和赋值均会被提升。



## 10 | 作用域链和闭包 ：代码中出现相同的变量，JavaScript引擎是如何选择的？

什么是作用域链，并通过作用域链再来讲讲什么是闭包

1. function bar() {
        console.log(myName)
    }
    function foo() {
        var myName = "极客邦"
        bar()
    }
    var myName = "极客时间"
    foo()
2. let test1 = 1
        var innerBar = {
            test1: 3,
            getName:function(){
                console.log(test1)
                // return myName
            }
        }
    console.log(innerBar.getName()) //1 对象不是块级作用域，方法定义是在外层，innerBar是执行环境



## 11.this

变量值查找是在原型链上，原型链依据的是词法环境（定义时的结构）；this上的属性查找是在执行环境上查找。

ES6 中的箭头函数并不会创建其自身的执行上下文，所以箭头函数中的 this 取决于它的外部函数。（箭头函数在执行时比块级作用域的内容多，比函数执行上下文的内容少，砍掉了很多函数执行上下文中的组件。不过在箭头函数在执行时也是有变量环境的，因为还要支持变量提升！所以变量环境的模块还是砍不掉的）

outer的位置是在变量对象内



## 12 | 栈空间和堆空间：数据是如何存储的？

在 JavaScript 的执行过程中， 主要有三种类型内存空间，分别是代码空间（存储可执行代码）、栈空间（存储执行上下文）和堆空间。原始类型的数据值都是直接保存在“栈”中的，引用类型的值是存放在“堆”中的， JavaScript 引擎需要用栈来维护程序执行期间上下文的状态，如果栈空间大了话，所有的数据都存放在栈空间里面，那么会影响到上下文切换的效率，进而又影响到整个程序的执行效率



### 13：垃圾回收

垃圾回收策略一般分为手动回收和自动回收，java python JavaScript等高级预言为了减轻程序员负担和出错概率采用了自动回收策略。JavaScript的原始类型数据和引用数据是分别存储在栈和椎中的，由于栈和堆分配空间大小差异，垃圾回收方式也不一样。栈中分配空间通过ESP的向下移动销毁保存在栈中数据；堆中垃圾回收主要通过副垃圾回收器（新生代）和主垃圾回收器（老生代）负责的，副垃圾回收器采用scavenge算法将区域分为对象区域和空闲区域，通过两个区域的反转让新生代区域无限使用下去。主垃圾回收器采用Mark-Sweep（Mark-Compact Incremental Marking解决不同场景下问题的算法改进）算法进行空间回收的。无论是主副垃圾回收器的策略都是标记-清除-整理三个大的步骤。另外还有新生代的晋升策略（两次未清除的），大对象直接分配在老生代。副垃圾回收器执行速度快，而且容易满，所以回收频率会比主垃圾回收器高。

> 引用计数的垃圾回收方式有问题，会导致内存泄漏，所以现在流行的垃圾回收器都没有采用引用计数的方式！

观察是否有内存泄露：使用 chrome 的 Performance 面板，观察内存变化 如何多次垃圾回收后，整体趋势是向上，就存在内部泄漏的可能！



## 14：编译器和解释器

接下来要介绍的 V8 执行机制，能帮助你从底层了解 JavaScript，也能帮助你深入理解语言转换器 Babel、语法检查工具 ESLint、前端框架 Vue 和 React 的一些底层实现机制。因此，了解 V8 的编译流程能让你对语言以及相关工具有更加充分的认识

V8 执行JavaScript 代码的流程：依据 JavaScript 代码生成 AST 和执行上下文，再基于 AST 生成字节码，然后通过解释器执行字节码，通过编译器来优化编译字节码。

1. 生成抽象语法树（AST）和执行上下文。AST 的生成过程，先分词，再解析；有了 AST 后，接下来 V8 就会生成该段代码的执行上下文

2. 解释器 Ignition根据 AST生成字节码。执行机器码的效率是非常高效的，但在手机上内存占用问题非常大，字节码内存占用小，需要通过解释器将其转换为机器码后才能执行。

3. 执行。解释器 Ignition 在解释执行字节码的同时，收集代码信息，当它发现某一部分代码变热了之后，TurboFan 编译器便闪亮登场，把热点的字节码转换为机器码，并把转换后的机器码保存起来，以备下次使用。

   > 字节码配合解释器和编译器的技术称为即时编译（JIT）

优化 JavaScript 执行效率，你应该将优化的中心聚焦在单次脚本的执行时间和脚本的网络下载上，主要关注以下三点内容：
提升单次脚本的执行速度，避免 JavaScript 的长任务霸占主线程，这样可以使得页面快速响应交互；
避免大的内联脚本，因为在解析 HTML 的过程中，解析和编译也会占用主线程；
减少 JavaScript 文件的容量，因为更小的文件会提升下载速度，并且占用更低的内存。



## 15：消息队列和事件循环

浏览器页面是由消息队列和事件循环系统来驱动的。

如果有一些确定好的任务，可以使用一个单线程来按照顺序处理这些任务，这是第一版线程模型。要在线程执行过程中接收并处理新的任务，就需要引入循环语句和事件系统，这是第二版线程模型。如果要接收其他线程发送过来的任务，就需要引入消息队列，这是第三版线程模型。如果其他进程想要发送任务给页面主线程，那么先通过 IPC 把任务发送给渲染进程的 IO 线程，IO 线程再把任务发送给页面主线程。消息队列机制并不是太灵活，为了适应效率和实时性，引入了微任务。

> 宏任务是开会分配的工作内容，微任务是工作过程中被临时安排的内容

>部分css3的动画效果是在合成线程上实现的，不需要主线程介入，所以省去了重拍和重绘的过程，这就大大提升了渲染效率。JavaScript都是在在主线程上执行的，所以JavaScript的动画需要主线程的参与，所以效率会大打折扣

> JavaScript引擎是运行在渲染进程的主线程上的，是单线程执行的

>默认情况下每个标签页都会配套一个渲染进程，而一个渲染进程里有主线程、合成线程、IO线程等多个线程，【排版引擎 blink】 和【JavaScript引擎 v8】都工作在渲染进程的主线程上并且是互斥的，基于这点说页面是单线程架构



## 16 | WebAPI：setTimeout是如何实现的？



## 17：webApi: XMLHttpRequest

异步回调的第二种方式 把异步函数添加到微任务队列中：Promise的resolve和reject会创建微任务。还有MutationObserver，如果监听了某个节点，那么通过DOMAPI修改这些被监听的节点也会产生微任务。

建立tcp连接是在xhr open还是send?open方法仅仅是配置数据，没有任何真实的连接产生，所有连接阶段都是在send之后

es6中可以通过一个 fetch api来请求，fetch采用了promise来封装，在使用方式上更强现代化，同时还原生支持async/await。在chromium中，fetch是完全重新实现的，和xmlhttprequest没有什么关系。在项目中推荐使用fetch



## 18 | 宏任务和微任务：不是所有任务都是一个待遇

异步回调函数的两种形式：宏任务、微任务。浏览器是如何实现微任务的，包括微任务队列、检查点（在当前宏任务中的 JavaScript 快执行完成时，也就在 JavaScript 引擎准备退出全局执行上下文并清空调用栈的时候，JavaScript 引擎会检查全局执行上下文中的微任务队列）等概念

MutationObserver通过异步操作解决了同步操作的性能问题；通过微任务解决了实时性的问题。



产生回调地狱的原因：
多层嵌套的问题；
每种任务的处理结果存在两种可能性（成功或失败），那么需要在每种任务执行结束后分别处理这两种可能性。
Promise 通过回调函数延迟绑定、回调函数返回值穿透和错误“冒泡”技术解决了上面的两个问题。

## 20 | async/await：使用同步的方式去写异步代码



## 21 | Chrome开发者工具：利用网络面板做性能分析

时间线面板：

1. Queuing：CSS、HTML、JavaScript 等都是页面中的核心文件，所以优先级最高；而图片、视频、音频这类资源就不是核心资源，优先级就比较低；6 个 TCP 连接的限制；网络进程在为数据分配磁盘空间
   优化：域名分片技术：站点下面的资源放在多个域名下面；把站点升级到 HTTP2：没有每个域名最多维护 6 个 TCP 连接的限制
2. Stalled：推迟
3. Proxy Negotiation ：使用代理的话会有协商阶段，它表示代理服务器连接协商所用的时间
4. Initial connection/SSL 阶段：和服务器建立连接的阶段，包括建立 TCP 连接的时间；使用了 HTTPS 协议，还需要 SSL 握手时间，用来协商一些加密信息的
   优化：请求合并
5. Request sent 阶段：时间很短
6. Waiting (TTFB)也称“第一字节时间”：等待接收服务器第一个字节的数据，是反映服务端响应速度的重要指标，TTFB 时间越短，说明服务器响应越快
   优化：服务器生成页面数据的时间过久，想办法去提高服务器的处理速度，比如通过增加各种缓存的技术；网络问题，可以使用 CDN 来**缓存**一些静态文件；发送请求头时带上了多余的用户信息：在发送请求时就去尽可能地减少一些不必要的 Cookie 数据信息。
7. Content Download：从第一字节时间到接收到全部响应数据所用的时间
   优化：减少文件大小，比如**压缩**、去掉源码中不必要的注释等方法

## 22 | DOM树：JavaScript是如何影响DOM树构建的？

网络进程接收到响应头，如果content-type 的值是“text/html”，浏览器就会为该请求选择或者创建一个渲染进程，网络进程加载了多少数据，HTML 解析器便解析多少数据

字节流转换为 DOM的三个阶段：

1. 通过分词器将字节流转换为 Token：Tag Token 和文本 Token
2. 将 Token 解析为 DOM 节点，将 DOM 节点添加到 DOM 树中，第二个和第三个阶段同步进行

引入 JavaScript 线程会阻塞 DOM，JavaScript 可能要修改当前已经生成的 DOM 结构。

1. Chrome 浏览器做了很多优化，其中一个主要的优化是预解析操作。当渲染引擎收到字节流之后，会开启一个预解析线程，用来分析 HTML 文件中包含的 JavaScript、CSS 等相关文件，解析到相关文件之后，预解析线程会提前下载这些文件；

2. **开发**可以使用 CDN 来加速 JavaScript 文件的加载，压缩 JavaScript 文件的体积。另外，如果 JavaScript 文件中没有操作 DOM 相关代码，就可以将该 JavaScript 脚本设置为异步加载，通过 async 或 defer 来标记代码

   > 使用 async 标志的脚本文件一旦加载完成，会立即执行；而使用了 defer 标记的脚本文件，需要在 DOMContentLoaded 事件之前执行。

3. 执行 JavaScript 之前，需要先解析 JavaScript 语句之上所有的 CSS 样式。所以如果代码里引用了外部的 CSS 文件，那么在执行 JavaScript 之前，还需要等待外部的 CSS 文件下载完成，并解析生成 CSSOM 对象之后，才能执行 JavaScript 脚本。

JavaScript 会阻塞 DOM 生成，而样式文件又会阻塞 JavaScript 的执行，所以在实际的工程中需要重点关注 JavaScript 文件和样式表文件，使用不当会影响到页面性能的

渲染引擎还有一个安全检查模块叫 XSSAuditor，是用来检测词法安全的。在分词器解析出来 Token 之后，它会检测这些模块是否安全，比如是否引用了外部脚本，是否符合 CSP 规范，是否存在跨站点请求等。如果出现不符合规范的内容，XSSAuditor 会对该脚本或者下载任务进行拦截

## 23 | 渲染流水线：CSS如何影响首次加载时的白屏时间？

发起 URL 请求开始，到首次显示页面的内容，在视觉上经历的三个阶段：

1. 请求发出去之后，到提交数据阶段，这时页面展示出来的还是之前页面的内容

2. 提交数据之后（还是获取到响应头之后？）渲染进程创建空白页面、等待 CSS 文件和 JavaScript 文件的加载完成、生成 CSSOM 和 DOM、合成布局树、首次渲染，这段时间称为**解析白屏**

   1. 请求 HTML 数据和构建 DOM 中间有一段空闲时间，这个空闲时间有可能成为页面渲染的瓶颈

   2. 可能需要下载js、css文件：

      1. 内联 JavaScript、内联 CSS 
      2. 减少文件大小：移除不必要的注释（用webpack）、压缩 JavaScript 文件
      3. 通过媒体查询拆分大的 CSS 文件
      4. 不需要在解析 HTML 阶段使用的 JavaScript 标记上 sync 或者 defer

   3. DOM 构建结束之后、theme.css 文件还未下载完成的这段时间内，渲染流水线无事可做

      合成布局树：过滤掉不需要显示的元素、样式计算、几何位置计算布局

3. 页面生成

## 24 | 分层和合成机制：为什么CSS动画比JavaScript高效？

本文我们主要讲解渲染引擎的分层和合成机制，有助于你更加深刻地理解 CSS 动画和 JavaScript 底层工作机制。

显示器每秒固定读取 60 次**前缓冲区**中的图像，并将读取的图像显示到显示器上；

显卡的职责就是合成新的图像，并将图像保存到**后缓冲区**中。

我们把渲染流水线生成的每一副图片称为一帧，把渲染流水线每秒更新了多少帧称为帧率，比如滚动过程中 1 秒更新了 60 帧，那么帧率就是 60Hz（或者 60FPS）

分层和合成机制代表了当今最先进的渲染技术，Chrome 中的合成技术，可以用三个词来概括总结：分层、分块和合成

当进行到下一帧的渲染时，合成器只需要将两个层进行相应的变化操作就可以了；合成线程会将每个图层分割为大小固定的图块，从计算机内存上传到 GPU 内存的操作会比较慢，Chrome 又采取了一个策略：纹理上传，在首次合成图块的时候使用一个低分辨率的图片

## 25 | 页面性能：如何系统地优化页面？

影响到我们体验的因素主要都在加载阶段和交互阶段，让页面更快地显示和响应。

**加载阶段**：JavaScript、首次请求的 HTML 资源文件、CSS 文件，这些能阻塞网页首次渲染的资源称为**关键资源**。影响因素：

1. 关键资源个数
2. 关键资源大小
3. 请求关键资源需要多少个 RTT（Round Trip Time）：表示从发送端发送数据开始，到发送端收到来自接收端的确认，总共经历的时延，通常 1 个 HTTP 的数据包在 14KB 左右，可以通过优化前俩项，还可以使用 CDN 来减少每次 RTT 时长（14kb的数据咋来的？包的大小好像是由mtu定的，应该不是写死的）

**交互阶段**：帧的渲染速度决定了交互的流畅度，该阶段讨论页面优化实际上就是讨论渲染引擎是如何渲染帧的，大的原则就是**让单个帧的生成速度变快**

1. 减少 JavaScript 脚本执行时间。在交互阶段，对 JavaScript 脚本总的原则就是不要一次霸占太久主线程：将一次执行的函数分解为多个任务，使得每次的执行时间不要过久；把一些和 DOM 操作无关且耗时的任务放到 Web Workers 中去执行
2. 避免强制同步布局（JavaScript 强制将计算样式和布局操作提前到当前的任务中）
3. 避免布局抖动（在一次 JavaScript 执行过程中，多次执行强制布局和抖动操作）：避免方式和强制同步布局一样，都是尽量不要在修改 DOM 结构时再去查询一些相关值
4. 合理利用 CSS 合成动画：合成动画是直接在合成线程上执行的，能让 CSS 处理动画，就尽量交给 CSS 来操作；如果能提前知道对某个元素执行动画操作，那就最好将其标记为 **will-change**，这是告诉渲染引擎需要将该元素单独生成一个图层
5. 避免频繁的垃圾回收：在一些函数中频繁创建临时对象，那么垃圾回收器也会频繁地去执行垃圾回收策略，会占用主线程影响到其他任务的执行，尽可能优化储存结构，尽可能避免小颗粒对象的产生

## 26 | 虚拟DOM：虚拟DOM和实际的DOM有何不同？

dom操作容易牵一发而动全身，重流、重绘、合成、强制同步布局和布局抖动

**虚拟 DOM 到底怎么运行的**

1. 创建阶段。首先依据 JSX 和基础数据创建出来虚拟 DOM，它反映了真实的 DOM 树的结构。然后由虚拟 DOM 树创建出真实 DOM 树，真实的 DOM 树生成完后，再触发渲染流水线往屏幕输出页面。

2. 更新阶段。如果数据发生了改变，那么就需要**根据新的数据创建一个新的虚拟 DOM 树**；然后 React 比较新旧dom树，**找出变化的地方**，并把变化的地方一次性**更新**到真实的 DOM 树上；最后渲染引擎更新**渲染**流水线，并生成新的页面。

   > React 团队比较两个虚拟 DOM 的新算法称为 Fiber reconciler，在执行算法的过程中出让主线程，这样就解决了老算法Stack reconciler 函数在一个递归函数里执行，占用时间过久的问题。

**双缓存**，可以让你先将计算的中间结果存放在另一个缓冲区中，等全部的计算结束，该缓冲区已经存储了完整的图形之后，再将该缓冲区的图形数据一次性复制到显示缓冲区，这样就使得整个图像的输出非常稳定。可以把虚拟 DOM 看成是 DOM 的一个 buffer，和图形显示一样，它会在完成一次完整的操作之后，再把结果应用到 DOM 上，这样就能减少一些不必要的更新，同时还能保证 DOM 的稳定输出。双缓存是一种经典的思路，应用在很多场合，能解决页面无效刷新和闪屏的问题，虚拟 DOM 就是双缓存思想的一种体现

**mvc模型**：能够大大减轻复杂项目的耦合度，使得程序易于维护，核心思想就是将数据和视图分离，它们之间的通信都是通过控制器来完成的。根据不同的通信路径和控制器不同的实现方式，基于 MVC 又能衍生出很多其他的模式，如 MVP、MVVM 等。分析基于 React 或者 Vue 这些前端框架时，我们需要先重点把握大的 MVC 骨架结构，然后再重点查看通信方式和控制器的具体实现方式，这样我们就能从架构的视角来理解这些前端框架了。监控 DOM事件、通知视图、生成新的虚拟 DOM、触发 DOM 节点的更新、页面的更新

## 27 | 渐进式网页应用（PWA）：它究竟解决了Web应用的哪些问题？

什么是 PWA：是一套理念，渐进式增强 Web 的优势，并通过技术手段渐进式缩短和本地应用或者小程序的距离。基于这套理念之下的技术都可以归类到 PWA

PWA 又是以什么方式切入到移动端的：通过引入 Service Worker 来试着解决**离线存储和消息推送**的问题，通过引入 manifest.json 来解决一级**入口**的问题。

> manifest.json 配置文件，可以让开发者自定义桌面的图标、显示名称、启动方式等信息，还可以设置启动画面、页面主题颜色等信息

Service Worker 主要**思想**是在页面和网络之间**增加一个拦截器，用来缓存和拦截请求**，此外**让其运行在主线程之外**就是 Service Worker 借鉴 Web Worker 的思想，区别是：

1. 每次 JavaScript 脚本执行完成之后都会退出，执行结果也不能保存下来，如果下次还有同样的操作，就还得重新来一遍。所以 Service Worker 需要在 Web Worker 的基础之上加上**储存**功能
2. 由于 Service Worker 还需要会为多个页面提供服务，所以还不能把 Service Worker 和单个页面绑定起来，目前的 Chrome 架构中，Service Worker 是**运行在浏览器进程**中的，因为浏览器进程生命周期是最长的

>  Web Worker 中是没有当前页面的 DOM 环境的，所以在 Web Worker 中只能执行一些和 DOM 无关的 JavaScript 脚本，并通过 postMessage 方法将执行的结果返回给主线程。所以说在 Chrome 中， Web Worker 其实就是**在渲染进程中开启的一个新线程**，它的**生命周期是和页面关联**的

**消息推送**也是基于 Service Worker 来实现的，消息推送时，浏览器页面也许并没有启动，这时就需要 Service Worker 来接收服务器推送的消息

**安全**：要使站点支持 Service Worker，首先要将站点升级到 **HTTPS**。HTTP 采用的是明文传输， HTTPS 的通信数据都是经过加密的，即便拦截了数据，也无法破解数据内容，而且 HTTPS 还有校验机制，通信双方很容易知道数据是否被篡改。此外，Service Worker 还需要同时支持 Web 页面默认的**安全策略、储入同源策略、内容安全策略（CSP）**等

## 28 | WebComponent：像搭积木一样构建Web应用

 CSS 和 DOM 是阻碍组件化的两个因素，WebComponent 提供了对局部视图封装能力，具体涉及到了 Custom elements（自定义元素）、Shadow DOM（影子 DOM）和HTML templates（HTML 模板）三种技术

使用 WebComponent，通常要实现下面三个步骤

1. 使用 template 属性来创建模板。
2. 创建类并使用 customElements.define 来自定义元素（customElements.define('geek-bang', 类名)。在该类的构造函数中要完成三件事：查找模板内容；创建影子 DOM；再将模板添加到影子 DOM 上（const shadowDOM = this.attachShadow({ mode: 'open' })）
3. 像正常使用 HTML 元素一样使用该元素

影子 DOM 内部的**样式是不会影响**到全局 CSSOM 的；使用 DOM 接口也是**无法直接查询到影子 DOM** 内部元素的，想查找影子 DOM 内部的元素需要专门的接口，所以通过这种方式又将影子内部的 DOM 和外部的 DOM 进行了隔离；影子 DOM 的 **JavaScript 脚本不会被隔离**，因为 JavaScript 语言本身已经可以很好地实现组件化了。

实现：每个影子 DOM 都有一个 shadow root 的根节点。通过 DOM 接口去查找元素时，渲染引擎会去判断 geek-bang 属性下面的 shadow-root 元素是否是影子 DOM，如果是影子 DOM，那么就直接跳过 shadow-root 元素的查询操作；生成布局树时，判断 geek-bang 属性下面的 shadow-root 元素是否是影子 DOM，如果是，那么在影子 DOM 内部元素的节点选择 CSS 样式的时候，会直接使用影子 DOM 内部的 CSS 属性。

## 加餐三｜加载阶段性能：使用Audits来优化Web性能

页面在加载过程中各个重要的时间节点：

1. First Paint（FP）：渲染进程确认要渲染当前的请求后，渲染进程会创建一个空白页面的这个时间点

2. FMP，这个是首次有效绘制，由于 FMP 计算复杂，而且容易出错，现在不推荐使用该指标，在 FCP 和 LCP 中间，推荐使用 LCP 指标。页面中绘制了第一个像素的时间点称为 First Content Paint（FCP），继续执行 JavaScript 脚本，当首屏内容完全绘制完成的时间点称为 Largest Content Paint（LCP）。可能是加载关键资源花的时间过久，也有可能是 JavaScript 执行过程中所花的时间过久

   > 首屏时间 (Speed Index)，这就是我们上面提到的 LCP，它表示填满首屏页面所消耗的时间

3. 首次 CPU 空闲时间 (First CPU Idle)，也称为 First Interactive，它表示页面达到最小化可交互的时间，也就是说并不需要等到页面上的所有元素都可交互，只要可以对大部分用户输入做出响应即可。要缩短首次 CPU 空闲时长，我们就需要尽可能快地加载完关键资源，尽可能快地渲染出来首屏内容

   > 前三个是上面时间面板上分析的内容，上面的分析角度是开发的角度，这里是用户运营视角

4. 完全可交互时间 (Time to Interactive)，简称 TTI，推迟执行一些和生成页面无关的 JavaScript 工作

5. 最大估计输入延时 (Max Potential First Input Delay），这个指标是估计你的 Web 页面在加载最繁忙的阶段， 窗口中响应用户输入所需的时间。为了改善该指标，可以使用 WebWorker 来执行一些计算，从而释放主线程；重构 CSS 选择器，以确保它们执行较少的计算



## 加餐四｜页面性能工具：如何使用Performance？

第一步是配置 Performance；第二步是生成报告页；第三步就是人工分析报告页，并找出页面的性能瓶颈。

报告页分为三个主要的部分，分别为概览面板、性能指标面板和详情面板。

概览面板按照时间顺序做成图表的形式展现几个关键指标，诸如页面帧速 (FPS)、CPU 资源消耗、网络请求流量、V8 内存使用量 (堆内存) 等

性能面板：

1. Main 指标记录渲染主线程的任务执行过程
2. Compositor 指标记录了合成线程的任务执行过程：渲染主线程在生成层树 (LayerTree) 之后，根据层树生成每一层的绘制列表，这个过程称为绘制 (Paint)。在绘制阶段结束之后，渲染主线程会将这些绘列表制提交 (commit)给合成线程，并由合成线程合成出来漂亮的页面。Compositor指标监控合成线程的任务执行记录
3. GPU 指标记录了 GPU 进程主线程的任务执行过程：在合成线程执行任务的过程中，还需要 GPU 进程的配合来生成位图
4. Raster 指标：GPU 生成位图的过程称为光栅化，合成线程又维护了一个光栅化线程池 (Raster)，用来让 GPU 执行光栅化的任务，避免合成线程直接和 GPU 进程进行通信阻塞后面的合成任务，点开 Raster 项，可以看到它维护了多个线程
5. Chrome_ChildIOThread 指标对应的就是 IO 线程的任务记录
6. Network 指标、Timings 指标（上一节也介绍过的FP、FCP、LCP等）、 Frames 指标、 Interactions 指标，用来记录用户交互操作

要查看这些记录的详细信息，就需要查看详情面板

> 我们通过概览面板来定位问题的时间节点，然后再使用性能面板分析该时间节点内的性能数据

## 加餐五 | 性能分析工具：如何分析Performance中的Main指标？

在导航流程中，主要是处理响应头的数据，并执行一些老页面退出之前的清理操作。在解析 HTML 数据阶段，主要是解析 HTML 数据、解析 CSS 数据、执行 JavaScript 来生成 DOM 和 CSSOM。最后在生成最终显示位图的阶段，主要是将生成的 DOM 和 CSSOM 合并，这包括了布局 (Layout)、分层、绘制、合成等一系列操作。

 ```<body>
    <script>
        let p = new Promise(function (resolve, reject) {
            resolve("成功!"); 
        });


        p.then(function (successMessage) {
            console.log("p! " + successMessage);
        })


        let p1 = new Promise(function (resolve, reject) {
            resolve("成功!"); 
        });


        p1.then(function (successMessage) {
            console.log("p1! " + successMessage);
        })
    </script>
</bod>


<body>
    <script>
        let p = new Promise(function (resolve, reject) {
            resolve("成功!");
        });


        p.then(function (successMessage) {
            console.log("p! " + successMessage);
        })
    </script>
    <script>
        let p1 = new Promise(function (resolve, reject) {
            resolve("成功!");
        });


        p1.then(function (successMessage) {
            console.log("p1! " + successMessage);
        })
    </script>
</body>
结合 Main 指标，来分析上面这两段代码中微任务执行的时间点有何不同，并给出分析结果和原因
 ```

# 